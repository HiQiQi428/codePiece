# 接口模式
### 适配器模式：使用不同接口的类提供的服务来为客户端提供他所期望的接口
### 外观模式：为子系统提供一个接口，便于它的使用
* 工具类：全静态方法，外观类可能是工具类
* 示例类：展示如何使用类或子系统，为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或者使用。即封装一组模块
### 合成模式：保证客户端调用单对象和组合对象的一致性
* 安全性合成模式是指：从客户端使用合成模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。
* 透明性合成模式是指：从客户端使用合成模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。
* 对于合成模式而言，在安全性和透明性上，会更看重透明性，毕竟合成模式的目的是：让客户端不再区分操作的是树枝对象还是树叶对象，而是以一个统一的方式来操作。
* 而且对于安全性的实现，需要区分是树枝对象还是树叶对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。
### 桥接模式：将抽象与抽象方法的实现相互分离来实现解耦，以便二者可以相互独立的变化
* 桥接模式应对的场景有方向性的，桥绑定的一方都是被调用者，属于被动方，抽象方属于主动方。
# 职责型模式
### 单例模式：确保一个类仅有一个实例，并提供一个全局访问点
* 多线程环境下注意同步
* 最好的方式是：类只需知道和它协作的对象，不必了解创建它所需要的限制
### 观察者模式：在多个对象之间定义一对多的依赖关系，当一个对象的状态发生改变时，会通知依赖它的对象，并根据新状态作出相应的反应
* 其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。
### 调停者模式：定义一个对象，封装一组对象的交互，从而降低对象间的耦合度，避免了对象间的显式引用，并且可以独立地改变对象的行为
* 这样原本复杂的网状的类关系，变成了简单的星型类关系，调停者类位于核心，所有其他类位于外围，指向调停者。
* 调停者模式降低的是系统内部的耦合性，而外观模式降低的是系统之间的耦合性。
* 调停者模式更加细化，针对的是系统内部类与类之间的强耦合的解除，外观模式则较为统筹，针对的是整个系统对外的耦合性解除，二者都都有屏蔽复杂性的作用。
### 代理模式：通过提供一个代理或者占位符来控制对对象的访问
* 静态代理：代理类实现Subject接口，并接受一个Subject接口的对象，任何实现该接口的对象，都可以通过代理类进行代理
	* 增加了通用性
	* 每一个代理类都必须实现一遍委托类（代理类构造器参数）的接口，如果接口增加方法，则代理类也必须跟着修改
	* 代理类每一个接口对象对应一个委托对象，如果委托对象非常多，则静态代理类就非常臃肿，难以胜任。
* 动态代理：https://www.cnblogs.com/qifengshi/p/6566752.html
### 职责链模式：使多个对象都有机会处理同一个请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止（事件的冒泡处理方式）
* https://blog.csdn.net/u012810020/article/details/71194853
### 享元模式：通过共享来有效地支持大量细粒度的对象
* 不变性
	* 可以提高String Pool（字符串常量池）的效率和安全性
	* 多线程安全
* String讨论：https://www.cnblogs.com/wcyBlog/p/4073725.html
	* 字符串常量池
	* String对象缓存HashCode，由于不变性一个String对象拥有不变的HashCode
* 本质：对于某些需要创建大量实例的类，提取其中能被共享的属性形成一个新的类型，然后只创建一个实例用于共享。这样可以有效降低内存开销
	* 除了String，Integer、Byte、Short、Long、Character也使用了享元模式
# 构造型模式
### 构建者模式：将类的构建逻辑转移到类的实例化外部
### 工厂方法模式：定义一个用于创建对象的接口，并控制返回哪个类的实例 https://blog.csdn.net/akaic/article/details/52967120
* 工厂构造什么样的对象
	* 依赖于工厂抽象类的具体实现
	* 反射方式构造，依赖于传入的clazz
* 静态工厂模式：确定只有一个工厂类时，不再使用抽象工厂类，而使用静态工厂类
* 为什么要使用工厂方法模式？
<b>打个比方，你在 A 界面通过 new 的方式创建了一个咱们上面代码中的 ConcreteProductA 的实例，这样看上去是比使用工厂方法模式要简单的多，但是，如果你在界面B、C、D、E等等界面中都是用到了 ConcreteProductA 这个对象呢？是，你可能会说，那也好办啊，直接创建不就行了。但是你有没有考虑过这么一种情况，如果说现在的 ConcreteProductA 的构造逻辑改变了，那你是不是需要在所有采用 new ConcreteProductA 的地方都要动代码，而使用 工厂方法模式就不会，应为 产品类的创建是在工厂中进行创建的，我只需要改一下工厂方法的逻辑即可；这是一方面，其实还有一个好处：就拿咱们上面的例子来说吧，现在有 A、B两个产品，如果没有采用工厂方法模式，那么我们需要手动创建产品A和产品B的实例，如果说后面我不想使用产品A和产品B了，我这边要出一个新产品C，那么你通过 new 创建产品Ａ、B的地方是不是还是要改？而工厂方法模式就不用，我只需要在工厂方法中将产品 C 返回即可。这就是工厂方法的最大优点。</b>
### 抽象工厂模式：允许创建一族相关或相互依赖的对象
### 原型模式：通过复制一个现有的对象来生成新的对象，而不是通过实例化的方式 https://blog.csdn.net/DINGYANG0315/article/details/77709618
* 两种形式
	* 简单形式
	* 登记形式
* 比较：如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。
* Java中的克隆方法：当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份
* Cloneable接口：Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常
* 浅克隆：只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象
* 深度克隆：深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。<b>深度克隆要深入到多少层，是一个不易确定的问题。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅度克隆还是继续采用深度克隆。因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现循环引用的问题，必须小心处理。</b>
### 备忘录模式：意在为对象状态提供存储和恢复功能 https://blog.csdn.net/xu__cg/article/details/53432286
* 当备忘点较多时
	* 设置栈将备忘点压栈
	* 将多个备忘录对象持久化和序列化保存到本地
* 优点
	* 备忘录模式可以把发起人内部信息对象屏蔽起来，从而可以保持封装的边界
	* 简化了发起人类。当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原
* 缺点
	* 如果状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象比较昂贵
	* 当发起者对象的状态改变的时候，有可能这个协议无效。如果状态改变的成功率达不到要求，可以考虑采取“假如”协议模式
* 应用场景: 事务回滚
# 操作型模式 
* https://blog.csdn.net/wangyongyao1989/article/details/79299224
* 操作和方法：操作是一个服务的规格，它可以被类的实例调用，意味着操作是方法的抽象，方法是操作的实现
* 签名：方法的签名包括方法名、传入参数的数量以及类型。方法的签名不包括返回类型，就是重载规则。方法签名代表了客户调研的方法，操作是可以被请求的服务规格。当涉及不同类中的方法拥有相同的接口，使用术语“操作”。当涉及如何将Java方法调研匹配到接受对象的方法上时，使用术语“签名”。签名依赖于方法的名字和参数，但是不依赖于方法的返回类型
### 模板方法模式：在方法中实现算法，推迟对算法步骤的定义使得子类能够重新实现
* 模板方法钩子：钩子是一个方法回调，可以让开发者将自己的代码插入到程序的指定位置。当希望使用其他开发者的代码时，或者希望在别的程序中插入自己的代码时，就可以使用钩子。开发者可以在你需要的时候增加一个方法调用。通常，开发者会为钩子提供一个存根实现。一旦其他客户端就不再需要钩子，就没有必要再重写它。
* 优点
	* 封装不变部分，扩展可变部分：把认为不变部分的算法封装到父类实现，可变部分则可以通过继承来实现，很容易扩展
	* 提取公共部分代码，便于维护
	* 行为由父类控制，由子类实现
### 状态模式：将表示对象状态的逻辑分散到代表状态的不同类中 https://blog.csdn.net/nmgrd/article/details/70262540
### 策略模式：将可互换的方法封装在各自独立的类中，并且让每个方法都实现一个公共的操作 https://blog.csdn.net/zhangliangzi/article/details/52161211
* 策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类
* 重心：策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性
* 平等性：各个策略的平等性，使得算法之间可以相互替换。所有算法在实现上也应该是相互独立的，没有相互依赖的
* 唯一性：每一个时刻只能使用一个具体的策略实现对象
* 公有行为：所有的具体策略类都有一些公有的行为。这些行为被抽象到抽象策略角色Strategy类中。这个类必须用Java抽象类实现？
* 比较状态模式
	* 重构的主要目的是将某个操作分散到一组相关的类中，就这点而言策略模式和状态模式是一致的。显然多态使得状态模式和策略模式的结构看起来几乎完全一致
	* 但是策略和状态是两种完全不同的思想，在对状态和策略进行建模时，这种差异会带来不同的问题。比如在进行状态建模时，状态的迁移至关重要，而策略建模却无需考虑这一问题。另外一个区别是策略模式允许客户选择或者提供某个策略，而状态模式却很少这样设计
* 优点
	* 提供了管理相关算法族的办法，策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共代码集中在父类中，从而避免代码重复（模板方法模式）
	* 避免多重条件语句。多重条件语句不易维护
* 缺点
	* 客户必须知道所有的策略类，并自行决定使用哪一个策略类。客户必须理解这些算法的区别
	* 如果备选策略很多的话，对象数目会很多
### 命令模式：将请求封装在对象内部 https://blog.csdn.net/sjyttkl/article/details/73536297
* 直接调用是执行方法的一般方式。然而，有时我们无法控制方法执行的时机与上下文。这种情况下，可以将方法封装在对象的内部。通过在对象内部存储调用方法所需要的信息。就可以让客户端或者服务决定何时调用该方法
* 命令模式可以将请求封装在一个对象中，允许你可以像管理对象一样去管理方法，传递并且在合适的时机去调用它们
* 命令模式的另一个用处是，允许在服务执行客户类代码。服务经常在调用客户代码的前后执行。最后，除了可以控制方法的执行时间和上下文外。命令模式还可以提供一个<b>钩子机制</b>，允许客户代码作为算法执行的一部分
### 解析器模式：根据实现定义好的一系列组合规则，组合可执行对象 https://blog.csdn.net/wbwjx/article/details/52456114
* 优点：灵活性强，当我们想对文法规则进行扩展延伸时,只需要增加相应的非终结符解释器,并在构建语法树的时候使用新增的解释器对象进行具体的解释即可
* 缺点：每个文法都可以对应至少一个解释器，所以会生成大量的类，后期维护困难。而且对应复杂的文法，构建语法树显得一场繁琐
# 扩展型模式
* Liskov替换原则（LSP）：主要思想是一个类的实例应该具有其父类的所有功能
* 迪米特法则（LoD）：每个方法只能给有限的对象发送消息
* Refacotring: Improving the Design of Existing Code 重构法则
### 装饰器模式：意在运行时组合操作的新变化
* https://blog.csdn.net/erica_1230/article/details/54782519
* 以对客户端透明的方式扩展对象的功能，可以在不创建更多子类的情况下，扩展对象的功能，是继承关系的一个替代方案
* 特点
	* 装饰者和被装饰者拥有相同的超类型（可能是抽象类也可能是接口）
	* 在装饰类中包含一个被装饰组件类的对象引用
	* 可以为被装饰对象添加额外的功能
	* 在装饰类中重写被装饰组件类中的方法，并对被装饰组件类中对应的方法调用（代理模式）
	* 因为装饰者和被装饰者拥有相同的抽象类型，因此在任何需要原始对象（被包装）的场合，都可以用装饰过的对象来替代它；可以用多个装饰类来包装一个对象，装饰类可以包装装饰类或被装饰对象。简而言之，装饰模式保持接口，增强性能；继承至Component同时包含一个Component作为其成员变量（装饰器模式动机中的动态地增加功能是在这里实现的）
* 构件
	* 抽象构件
	* 具体构件
	* 装饰角色
	* 具体装饰角色
* 比较适配器模式
	* 都拥有一个目标对象。装饰器通过包装一个装饰对象来扩展其功能，而又不改变其接口，这实际上是基于对象的适配器模式的一种变种
	* 适配器模式需要实现另外一个接口，而装饰器模式必须实现该对象的接口。适配器模式主要是为了接口的转换，而装饰者模式关注的是通过组合来动态的为被装饰者注入新的功能或行为(即所谓的责任)
* 优点
	* 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定加上或者移除一个装饰，继承关系是静态的，在编译前决定的
	* 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合
	* 装饰者类可以在被装饰者的行为前面或后面加上自己的行为，甚至取代被装饰者的行为，达到特定的目的
	* 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型
* 缺点：由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像
* 适用场景
	* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
	* 处理那些可以撤销的职责
	* 当不能采用生成子类的方式进行扩充时
### 迭代器模式：为顺序访问集合元素提供一种方式
* Enumeration、Interator、foreach
* 线程安全的迭代：许多应用程序崩溃的原因都是由于没有协调好线程之间的交互，迭代整个集合的方法常常是多线程应用失败的原因。```java.util.Collections```通过提供一个synchronized()方法类保证线程执行的安全
### 访问者模式：在不改变类层次结构的前提下，对该层次结构进行扩展
* https://blog.csdn.net/janice0529/article/details/41151987
* 它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为“对象结构”，访问者通过遍历对象结构实现对其中存储的元素的逐个操作
* 适用场景：当有多种类型的访问者(或是操作者) 对一组被访问者对象集合（或是对象结构）进行操作（其中对象集合也包含多种类型对象），不同的访问者类型对每一种具体的被访问者对象提供不同的访问操作，每种访问者类型对象对不同的被访问者也有不同的访问操作，那么这种场景就非常适用访问者模式
page 259